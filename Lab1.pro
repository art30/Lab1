/*      			РЕЗУЛЬТАТЫ ДОПРОСА
    На допрос вызваны четверо подозреваемых в ограблении: А, В, С, Д.
Неопровержимыми уликами доказано, что по крайней мере один из них виновен и что никто,
кроме А, В, С, Д, в ограблении не участвовал.

Кроме того, удалось установить следующее:
    1. А безусловно не виновен.
    2. Если В виновен, то у него был ровно один сообщник.
    3. Если С виновен, то у него было ровно два сообщника.
Инспектору Крэгу было особенно важно узнать, виновен или не виновен Д, так как Д был 
опасным преступником.

К счастью, приведенных выше удалось_установитьов достаточно, чтобы установить виновность 
или невиновность подозреваемого.
Виновен или не виновен Д?                               */

DOMAINS
% Перечисление имен из задачи
    имя = а; в; с; д
    виновность = symbol
    
    имена = имя*
    виновности = виновность*
    
    подозреваемый = подозреваемый(имя, виновность)
% Гипотеза - всевозможные комбинации имен и виновностей
    гипотеза = подозреваемый*
PREDICATES
% Вспомогательные процедуры
    nondeterm входит_в(имя, имена)
    nondeterm входит_в(виновность, виновности)
    nondeterm входит_в(подозреваемый, гипотеза)

    nondeterm удалось_установить(integer, гипотеза)
    
    nondeterm генерация_гипотезы(гипотеза)
    nondeterm проверка_гипотезы(гипотеза)
    
    nondeterm решение_без_повторов(виновности, виновности, виновности)
    nondeterm поиск_решения(виновность)
    nondeterm решения(виновность)
CLAUSES
% Вспомогательные процедуры
	входит_в(Name,[Name|_]).
	входит_в(Name,[_|Хвост]):-входит_в(Name,Хвост).
    
% 1. А не виновен
    удалось_установить(1, Гипотеза):-
        входит_в(подозреваемый(а, невиновен), Гипотеза).
% 2. Если В виновен, то у него был ровно один сообщник
    удалось_установить(2, Гипотеза):-
        входит_в(подозреваемый(в, виновен), Гипотеза),
        findall(Виновный, входит_в(подозреваемый(Виновный, виновен), Гипотеза), Виновные),
        Виновные = [_, _]; % Обязательно два виновных

        входит_в(подозреваемый(в, невиновен), Гипотеза).
% 3. Если С виновен, то у него было ровно два сообщника.
    удалось_установить(3, Гипотеза):-
        входит_в(подозреваемый(с, виновен), Гипотеза),
        findall(Виновный, входит_в(подозреваемый(Виновный, виновен), Гипотеза), Виновные),
        Виновные = [_, _, _]; % Обязательно три виновных

        входит_в(подозреваемый(с, невиновен), Гипотеза).
      
    проверка_гипотезы(Гипотеза):-
    % Должен быть хотябы один виновный
        входит_в(подозреваемый(_, виновен), Гипотеза),
    % Сверяем список с фактами из задачи
        удалось_установить(1, Гипотеза),
        удалось_установить(2, Гипотеза),
        удалось_установить(3, Гипотеза).

    генерация_гипотезы(Гипотеза):-
        ВариантыВиновности = [виновен,невиновен],

    % Устанавливаем то, что виновности каждого подозреваемого, принадлежат к "ВариантыВиновности"
        входит_в(ВиновностьА, ВариантыВиновности),
        входит_в(ВиновностьВ, ВариантыВиновности),
        входит_в(ВиновностьС, ВариантыВиновности),
        входит_в(ВиновностьД, ВариантыВиновности),
    
        Гипотеза = [
        % Возможные варианты виновностей к каждому подозреваемому
            подозреваемый(а, ВиновностьА),
            подозреваемый(в, ВиновностьВ),
            подозреваемый(с, ВиновностьС),
            подозреваемый(д, ВиновностьД)
        ].
     
    поиск_решения(ВиновностьД):-
        генерация_гипотезы(Гипотеза),
        проверка_гипотезы(Гипотеза),
% Выявляем виновность "д"
        входит_в(подозреваемый(д, ВиновностьД), Гипотеза).
      
    решения(УникальноеРешение):-
        findall(Решение, поиск_решения(Решение), ВсеРешения),
        решение_без_повторов(ВсеРешения, [], УникальныеРешения),
        входит_в(УникальноеРешение, УникальныеРешения).

% Постусловие. Если исходный список пустой, то возвращаем формирумый список как результат 
	решение_без_повторов([], Накопитель, СписокБезПовторов):-
		СписокБезПовторов = Накопитель.
% Если текущий элемент списка уже есть в формируемом списке (Накопитель) , то переходим к проверке
% остальных элементов     
	решение_без_повторов([ПервыйЭлемент|ОстальныеЭлементы], Накопитель, СписокБезПовторов):-
		входит_в(ПервыйЭлемент, Накопитель), 
		решение_без_повторов(ОстальныеЭлементы, Накопитель, СписокБезПовторов).
% Если текущий элемент списка отсутствует в формируемом списке (Накопитель), то добавляем его
% в Накопитель и переходим к проверке остальных элементов      
	решение_без_повторов([ПервыйЭлемент|ОстальныеЭлементы], Накопитель, СписокБезПовторов):-
		NOT(входит_в(ПервыйЭлемент, Накопитель)),
		решение_без_повторов(ОстальныеЭлементы, [ПервыйЭлемент|Накопитель], СписокБезПовторов).
GOAL 
    решения(Подозреваемый_Д).